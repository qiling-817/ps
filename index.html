<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>ç®€æ˜“ PS é£æ ¼å›¾ç‰‡ç¼–è¾‘å™¨</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: radial-gradient(circle at top left, #3b3f52 0, #18191f 55%, #101117 100%);
      color: #f5f5f5;
    }

    /* é¡¶éƒ¨æ¡ */
    header {
      padding: 16px 24px;
      background: linear-gradient(90deg, #272a33, #20222b);
      display: flex;
      align-items: center;
      gap: 16px;
      border-bottom: 1px solid #3b3e48;
      box-shadow: 0 2px 6px rgba(0,0,0,0.45);
      z-index: 2;
    }
    .app-title {
      width: 520px;
      text-align: center;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0.08em;
      color: #e8eaed;
    }
    .header-center {
      display: none;
    }
    .file-btn {
      position: relative;
      overflow: hidden;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #4c505b;
      background: radial-gradient(circle at top left, #3b3f4a, #252830);
      color: #e8eaed;
      font-size: 11px;
      cursor: pointer;
      gap: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.4);
    }
    .file-btn.file-full {
      width: 100%;
      justify-content: flex-start;
      padding: 10px 14px;
      font-size: 13px;
      border-radius: 10px;
    }
    .file-btn span.icon {
      font-size: 14px;
      opacity: 0.9;
    }
    .file-btn input[type="file"] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }
    #exportBtn {
      padding: 10px 16px;
      border-radius: 10px;
      border: 1px solid #1a73e8;
      background: linear-gradient(135deg, #1a73e8, #4285f4);
      color: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      box-shadow: 0 2px 6px rgba(26,115,232,0.7);
      white-space: nowrap;
    }
    #exportBtn:hover {
      filter: brightness(1.05);
    }

    #status {
      margin-left: auto;
      font-size: 11px;
      opacity: 0.85;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(120,120,120,0.4);
      color: #cfd3da;
      max-width: 240px;
      text-overflow: ellipsis;
      white-space: nowrap;
      overflow: hidden;
    }

    main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* å·¦ä¾§å·¥å…·æ  */
    #sidepanel {
      width: 520px;
      min-width: 520px;
      background: linear-gradient(180deg, #242631, #181a21);
      border-right: 1px solid #343744;
      padding: 20px;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.4);
    }
    .tool-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(89,96,122,0.7);
      background: radial-gradient(circle at top left, rgba(65,71,96,0.9), rgba(27,29,40,0.9));
      box-shadow: 0 4px 12px rgba(0,0,0,0.45);
    }
    .tool-group-title {
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #9aa0a6;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(94,99,117,0.7);
    }
    .tool-group button {
      width: 100%;
      padding: 5px 8px;
      border-radius: 6px;
      border: 1px solid rgba(120,124,139,0.8);
      background: linear-gradient(180deg, #323543, #262833);
      color: #e8eaed;
      cursor: pointer;
      font-size: 11px;
      text-align: left;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
    }
    .tool-group button span.key-hint {
      font-size: 10px;
      opacity: 0.75;
    }
    .tool-group button:hover {
      background: linear-gradient(180deg, #3a3e4e, #282b37);
      box-shadow: 0 1px 4px rgba(0,0,0,0.6);
    }
    .tool-group button.active {
      border-color: #8ab4f8;
      background: radial-gradient(circle at top left, #3c5a99, #283857);
      box-shadow: 0 0 0 1px rgba(44,118,255,0.7), 0 4px 10px rgba(0,0,0,0.7);
    }

    /* ç”»å¸ƒåŒºåŸŸ */
    #canvasContainer {
      flex: 1;
      position: relative;
      background: radial-gradient(circle at center, #252733 0, #111219 55%, #05060b 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      padding: 10px 12px;
    }

    #editorCanvas {
      background: #111;
      border-radius: 10px;
      border: 1px solid rgba(100,110,140,0.8);
      max-width: 100%;
      max-height: 100%;
      cursor: default;
      box-shadow: 0 8px 26px rgba(0,0,0,0.7);
    }

    #overlayInfo {
      position: absolute;
      bottom: 10px;
      left: 12px;
      background: rgba(0,0,0,0.65);
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid rgba(120,120,120,0.6);
      color: #e8eaed;
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <header>
    <div class="app-title">å¿«é€ŸPSåœºæ™¯å›¾</div>
    <div id="status">çŠ¶æ€ï¼šå°±ç»ª</div>
  </header>

  <main>
    <aside id="sidepanel">
      <div class="tool-group">
        <div class="tool-group-title">æ–‡ä»¶</div>
        <label class="file-btn file-full">
          <span class="icon">ğŸ–¼</span>
          <span>åŠ è½½åº•å›¾</span>
          <input type="file" id="bgLoader" accept="image/*" />
        </label>
        <label class="file-btn file-full">
          <span class="icon">ğŸ“</span>
          <span>åŠ è½½ç´ æ</span>
          <input type="file" id="fgLoader" accept="image/*" />
        </label>
        <button id="exportBtn">å¯¼å‡º PNG</button>
      </div>
      <div class="tool-group">
        <div class="tool-group-title">æ“ä½œå·¥å…·</div>
        <button id="moveToolBtn" class="active">ç§»åŠ¨å·¥å…· <span class="key-hint">V</span></button>
        <button id="transformToolBtn">å˜å½¢å·¥å…· <span class="key-hint">T</span></button>
        <button id="scaleUpBtn">ç­‰æ¯”æ”¾å¤§ <span class="key-hint">Ctrl + =</span></button>
        <button id="scaleDownBtn">ç­‰æ¯”ç¼©å° <span class="key-hint">Ctrl + -</span></button>
      </div>

      <div class="tool-group">
        <div class="tool-group-title">æŠ å›¾å·¥å…·</div>
        <button id="rectToolBtn">çŸ©å½¢æŠ å›¾ <span class="key-hint">R</span></button>
        <button id="penToolBtn">é’¢ç¬”æŠ å›¾ <span class="key-hint">P</span></button>
        <button id="applyMaskBtn">åº”ç”¨æŠ å›¾</button>
        <button id="clearMaskBtn">æ¸…é™¤æŠ å›¾</button>
      </div>

      <div class="tool-group">
        <div class="tool-group-title">æ“ä½œå†å²</div>
        <button id="undoBtn">æ’¤å› <span class="key-hint">Ctrl + Z</span></button>
        <button id="redoBtn">æ¢å¤æ’¤å› <span class="key-hint">Ctrl + Shift + Z</span></button>
        <button id="resetOpBtn">é‡ç½®æ“ä½œ</button>
      </div>
    </aside>

    <section id="canvasContainer">
      <canvas id="editorCanvas" width="1200" height="800"></canvas>
      <div id="overlayInfo">ç¼©æ”¾: 100% | ç´ æç¼©æ”¾: 100%</div>
    </section>
  </main>

  <script>
    const bgLoader = document.getElementById('bgLoader');
    const fgLoader = document.getElementById('fgLoader');
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');

    const moveToolBtn = document.getElementById('moveToolBtn');
    const transformToolBtn = document.getElementById('transformToolBtn');
    const scaleUpBtn = document.getElementById('scaleUpBtn');
    const scaleDownBtn = document.getElementById('scaleDownBtn');
    const penToolBtn = document.getElementById('penToolBtn');
    const rectToolBtn = document.getElementById('rectToolBtn');
    const applyMaskBtn = document.getElementById('applyMaskBtn');
    const clearMaskBtn = document.getElementById('clearMaskBtn');
    const exportBtn = document.getElementById('exportBtn');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const resetOpBtn = document.getElementById('resetOpBtn');

    const statusSpan = document.getElementById('status');
    const overlayInfo = document.getElementById('overlayInfo');

    let bgImg = null;   // åº•å›¾ Image
    let fgImg = null;   // ç´ æ Imageï¼ˆå¯èƒ½æ˜¯åŸå§‹å›¾ï¼Œä¹Ÿå¯èƒ½æ˜¯æŠ å›¾åè£åˆ‡çš„æ–°å›¾å±‚ï¼‰

    // è§†å›¾ç¼©æ”¾ä¸å¹³ç§»ï¼ˆç±»ä¼¼ PS é‡Œçš„æ•´ä½“ç¼©æ”¾å’ŒæŠ“æ‰‹å·¥å…·ï¼‰
    let viewScale = 1.0;
    let viewOffsetX = canvas.width / 2;
    let viewOffsetY = canvas.height / 2;

    // ç´ æå¹³ç§»/ç¼©æ”¾ï¼ˆéé€è§†æ—¶ä½¿ç”¨ï¼‰ â€”â€” ä¸–ç•Œåæ ‡
    let fgScale = 1.0;
    let fgPosX = 0; // å·¦ä¸Šè§’ä¸–ç•Œåæ ‡
    let fgPosY = 0;

    // ç´ æçš„å››è§’ï¼ˆä¸–ç•Œåæ ‡ï¼‰ï¼Œé¡ºåºï¼šTL, TR, BR, BL
    let fgQuad = null;
    let hasPerspective = false; // æ˜¯å¦å·²ç»è¿›è¡Œäº†é€è§†è‡ªç”±å˜å½¢

    // é’¢ç¬” / çŸ©å½¢æŠ å›¾è·¯å¾„ï¼šå­˜åœ¨ç´ æå±€éƒ¨åæ ‡ï¼ˆåŸå§‹åƒç´ ï¼‰ä¸­
    let maskPoints = []; // [{x,y},...]

    // çŸ©å½¢ç»˜åˆ¶ä¸´æ—¶çŠ¶æ€
    let isRectDrawing = false;
    let rectStartLocal = null;
    let rectCurrentLocal = null;

    // å·¥å…·æ¨¡å¼ï¼š"move" | "transform" | "pen" | "rect"
    let toolMode = 'move';

    // é¼ æ ‡æ‹–æ‹½çŠ¶æ€
    let isLeftDragging = false;
    let isRightDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    // ç§»åŠ¨ç´ æï¼ˆéé€è§†ï¼‰è®°å½•èµ·å§‹ä½ç½®
    let dragStartFgPosX = 0;
    let dragStartFgPosY = 0;

    // è§†å›¾å¹³ç§»èµ·å§‹åç§»
    let dragStartViewOffsetX = 0;
    let dragStartViewOffsetY = 0;

    // é’¢ç¬”ç§»åŠ¨ç‚¹
    let draggingPointIndex = -1;

    // å˜æ¢å·¥å…·ï¼šæ‹–åŠ¨è§’ç‚¹
    let draggingCornerIndex = -1; // 0-3
    let dragStartQuad = null; // æ‹–åŠ¨å¼€å§‹æ—¶çš„å››è§’å¤‡ä»½

    // å†å²è®°å½•ï¼ˆä»…é’ˆå¯¹å‰æ™¯ç´ æä¸æŠ å›¾ç­‰æ“ä½œï¼‰
    let history = [];
    let historyIndex = -1;
    let initialFgState = null; // åˆšåŠ è½½ç´ æåçš„åˆå§‹çŠ¶æ€

    function setStatus(msg) {
      statusSpan.textContent = 'çŠ¶æ€ï¼š' + msg;
    }

    // ========= åæ ‡æ¢ç®— =========
    function worldToScreen(x, y) {
      return {
        x: x * viewScale + viewOffsetX,
        y: y * viewScale + viewOffsetY
      };
    }

    function screenToWorld(sx, sy) {
      return {
        x: (sx - viewOffsetX) / viewScale,
        y: (sy - viewOffsetY) / viewScale
      };
    }

    // æ ¹æ®è½´å¯¹é½çŸ©å½¢æ›´æ–°å››è§’ï¼ˆéé€è§†æ—¶ä½¿ç”¨ï¼‰
    function updateFgQuadFromRect() {
      if (!fgImg) return;
      const w = fgImg.width * fgScale;
      const h = fgImg.height * fgScale;
      fgQuad = [
        { x: fgPosX,     y: fgPosY },      // TL
        { x: fgPosX + w, y: fgPosY },      // TR
        { x: fgPosX + w, y: fgPosY + h },  // BR
        { x: fgPosX,     y: fgPosY + h }   // BL
      ];
    }

    function pointInTriangle(px, py, ax, ay, bx, by, cx, cy) {
      const v0x = cx - ax;
      const v0y = cy - ay;
      const v1x = bx - ax;
      const v1y = by -ay;
      const v2x = px - ax;
      const v2y = py - ay;

      const dot00 = v0x * v0x + v0y * v0y;
      const dot01 = v0x * v1x + v0y * v1y;
      const dot02 = v0x * v2x + v0y * v2y;
      const dot11 = v1x * v1x + v1y * v1y;
      const dot12 = v1x * v2x + v1y * v2y;

      const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return (u >= 0) && (v >= 0) && (u + v <= 1);
    }

    function isPointInQuadScreen(sx, sy, quadScreen) {
      const p0 = quadScreen[0];
      const p1 = quadScreen[1];
      const p2 = quadScreen[2];
      const p3 = quadScreen[3];
      return (
        pointInTriangle(sx, sy, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y) ||
        pointInTriangle(sx, sy, p0.x, p0.y, p2.x, p2.y, p3.x, p3.y)
      );
    }

    function isPointOnFgScreen(sx, sy) {
      if (!fgImg || !fgQuad) return false;
      const quadScreen = fgQuad.map(p => worldToScreen(p.x, p.y));
      return isPointInQuadScreen(sx, sy, quadScreen);
    }

    function hitQuadCorner(sx, sy, quadScreen, radius = 10) {
      for (let i = 0; i < 4; i++) {
        const p = quadScreen[i];
        const dx = sx - p.x;
        const dy = sy - p.y;
        if (dx * dx + dy * dy <= radius * radius) return i;
      }
      return -1;
    }

    // ========= é’¢ç¬”/çŸ©å½¢è¾…åŠ© =========
    function worldToFgLocal(x, y) {
      return {
        x: (x - fgPosX) / fgScale,
        y: (y - fgPosY) / fgScale
      };
    }

    function hitMaskPointForPen(sx, sy, thresholdPx = 10) {
      if (!fgImg || maskPoints.length === 0) return -1;
      for (let i = 0; i < maskPoints.length; i++) {
        const p = maskPoints[i];
        const worldX = fgPosX + p.x * fgScale;
        const worldY = fgPosY + p.y * fgScale;
        const s = worldToScreen(worldX, worldY);
        const dx = s.x - sx;
        const dy = s.y - sy;
        if (dx * dx + dy * dy <= thresholdPx * thresholdPx) return i;
      }
      return -1;
    }

    function snapToAxis(base, target) {
      const dx = target.x - base.x;
      const dy = target.y - base.y;
      if (Math.abs(dx) >= Math.abs(dy)) {
        return { x: target.x, y: base.y }; // æ°´å¹³
      } else {
        return { x: base.x, y: target.y }; // å‚ç›´
      }
    }

    // ========= é€è§†ç»˜åˆ¶ =========
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function lerpPoint(p0, p1, t) {
      return { x: lerp(p0.x, p1.x, t), y: lerp(p0.y, p1.y, t) };
    }

    function drawWarpedImageScreen(ctx2d, srcImg, quadScreen, steps) {
      if (!srcImg) return;
      const [p0, p1, p2, p3] = quadScreen;
      const imgW = srcImg.width;
      const imgH = srcImg.height;
      const autoStepsY = Math.min(2000, Math.max(800, Math.floor(imgH * 4)));
      const autoStepsX = Math.min(2000, Math.max(800, Math.floor(imgW * 4)));
      const stepsY = steps ? Math.max(steps, autoStepsY) : autoStepsY;
      const stepsX = steps ? Math.max(steps, autoStepsX) : autoStepsX;

      ctx2d.save();
      ctx2d.imageSmoothingEnabled = true;
      ctx2d.globalAlpha = 1;

      // æ°´å¹³æ¡å¸¦
      for (let i = 0; i < stepsY; i++) {
        const t0 = i / stepsY;
        const t1 = (i + 1) / stepsY;
        const sy = t0 * imgH;
        const sh = (t1 - t0) * imgH;
        if (sh <= 0) continue;

        const lt = lerpPoint(p0, p3, t0);
        const rt = lerpPoint(p1, p2, t0);
        const lb = lerpPoint(p0, p3, t1);
        const rb = lerpPoint(p1, p2, t1);

        const w = imgW;

        const a = (rt.x - lt.x) / w;
        const b = (rt.y - lt.y) / w;
        const c = (lb.x - lt.x) / sh;
        const d = (lb.y - lt.y) / sh;
        const e = lt.x;
        const f = lt.y;

        ctx2d.save();
        ctx2d.setTransform(a, b, c, d, e, f);
        ctx2d.beginPath();
        ctx2d.moveTo(0, 0);
        ctx2d.lineTo(w, 0);
        ctx2d.lineTo(w, sh);
        ctx2d.lineTo(0, sh);
        ctx2d.closePath();
        ctx2d.clip();
        ctx2d.drawImage(srcImg, 0, sy, w, sh, 0, 0, w, sh);
        ctx2d.restore();
      }

      // å‚ç›´æ¡å¸¦
      for (let j = 0; j < stepsX; j++) {
        const s0 = j / stepsX;
        const s1 = (j + 1) / stepsX;
        const sx = s0 * imgW;
        const sw = (s1 - s0) * imgW;
        if (sw <= 0) continue;

        const tl = lerpPoint(p0, p1, s0);
        const tr = lerpPoint(p0, p1, s1);
        const bl = lerpPoint(p3, p2, s0);
        const br = lerpPoint(p3, p2, s1);

        const h = imgH;

        const a2 = (tr.x - tl.x) / sw;
        const b2 = (tr.y - tl.y) / sw;
        const c2 = (bl.x - tl.x) / h;
        const d2 = (bl.y - tl.y) / h;
        const e2 = tl.x;
        const f2 = tl.y;

        ctx2d.save();
        ctx2d.setTransform(a2, b2, c2, d2, e2, f2);
        ctx2d.beginPath();
        ctx2d.moveTo(0, 0);
        ctx2d.lineTo(sw, 0);
        ctx2d.lineTo(sw, h);
        ctx2d.lineTo(0, h);
        ctx2d.closePath();
        ctx2d.clip();
        ctx2d.drawImage(srcImg, sx, 0, sw, h, 0, 0, sw, h);
        ctx2d.restore();
      }

      ctx2d.restore();
    }

    function drawQuadOverlay(ctx2d, quadScreen, showHandles) {
      ctx2d.save();
      ctx2d.beginPath();
      ctx2d.moveTo(quadScreen[0].x, quadScreen[0].y);
      for (let i = 1; i < 4; i++) ctx2d.lineTo(quadScreen[i].x, quadScreen[i].y);
      ctx2d.closePath();
      ctx2d.setLineDash([6, 4]);
      ctx2d.lineWidth = 1;
      ctx2d.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx2d.stroke();
      ctx2d.setLineDash([]);

      if (showHandles) {
        for (let i = 0; i < 4; i++) {
          const p = quadScreen[i];
          ctx2d.beginPath();
          ctx2d.arc(p.x, p.y, 6, 0, Math.PI * 2);
          ctx2d.fillStyle = '#1a73e8';
          ctx2d.fill();
          ctx2d.strokeStyle = '#000';
          ctx2d.lineWidth = 1;
          ctx2d.stroke();
        }
      }
      ctx2d.restore();
    }

    // ========= é€è§†ç»“æœçƒ˜ç„™ä¸ºæ–°çš„å›¾å±‚ =========
    function bakePerspectiveToAxisAligned() {
      if (!fgImg || !fgQuad || !hasPerspective) return;

      // è®¡ç®—å½“å‰å››ä¸ªè§’ç‚¹åœ¨ä¸–ç•Œåæ ‡ä¸­çš„å¤–æ¥çŸ©å½¢
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of fgQuad) {
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      }

      const width = Math.max(1, Math.ceil(maxX - minX));
      const height = Math.max(1, Math.ceil(maxY - minY));

      const offCanvas = document.createElement('canvas');
      offCanvas.width = width;
      offCanvas.height = height;
      const offCtx = offCanvas.getContext('2d');

      // å°†å½“å‰å››è¾¹å½¢è½¬æ¢åˆ°æ–°ç”»å¸ƒçš„å±€éƒ¨åæ ‡ç³»ä¸­
      const localQuad = fgQuad.map(p => ({
        x: p.x - minX,
        y: p.y - minY
      }));

      // æŠŠå¸¦é€è§†çš„ç´ æç»˜åˆ¶åˆ°æ–°çš„è½´å¯¹é½ç”»å¸ƒä¸­
      drawWarpedImageScreen(offCtx, fgImg, localQuad, 0);

      // ç”¨æ–°ç”»å¸ƒæ›¿æ¢å½“å‰ç´ æå›¾å±‚
      fgImg = offCanvas;
      fgPosX = minX;
      fgPosY = minY;
      fgScale = 1.0;
      hasPerspective = false;
      updateFgQuadFromRect();
    }

    // ========= å†å²è®°å½• =========
    function clonePoints(arr) {
      if (!arr) return [];
      return arr.map(p => p ? { x: p.x, y: p.y } : null);
    }

    function getStateSnapshot() {
      if (!fgImg) return null;
      return {
        fgImg: fgImg,
        fgPosX: fgPosX,
        fgPosY: fgPosY,
        fgScale: fgScale,
        fgQuad: fgQuad ? clonePoints(fgQuad) : null,
        hasPerspective: hasPerspective,
        maskPoints: clonePoints(maskPoints),
        isRectDrawing: isRectDrawing,
        rectStartLocal: rectStartLocal ? { x: rectStartLocal.x, y: rectStartLocal.y } : null,
        rectCurrentLocal: rectCurrentLocal ? { x: rectCurrentLocal.x, y: rectCurrentLocal.y } : null
      };
    }

    function cloneState(state) {
      if (!state) return null;
      return {
        fgImg: state.fgImg,
        fgPosX: state.fgPosX,
        fgPosY: state.fgPosY,
        fgScale: state.fgScale,
        fgQuad: state.fgQuad ? clonePoints(state.fgQuad) : null,
        hasPerspective: state.hasPerspective,
        maskPoints: clonePoints(state.maskPoints),
        isRectDrawing: state.isRectDrawing,
        rectStartLocal: state.rectStartLocal ? { x: state.rectStartLocal.x, y: state.rectStartLocal.y } : null,
        rectCurrentLocal: state.rectCurrentLocal ? { x: state.rectCurrentLocal.x, y: state.rectCurrentLocal.y } : null
      };
    }

    function restoreState(state) {
      if (!state) return;
      fgImg = state.fgImg;
      fgPosX = state.fgPosX;
      fgPosY = state.fgPosY;
      fgScale = state.fgScale;
      fgQuad = state.fgQuad ? clonePoints(state.fgQuad) : null;
      hasPerspective = state.hasPerspective;
      maskPoints = state.maskPoints ? clonePoints(state.maskPoints) : [];
      isRectDrawing = state.isRectDrawing;
      rectStartLocal = state.rectStartLocal ? { x: state.rectStartLocal.x, y: state.rectStartLocal.y } : null;
      rectCurrentLocal = state.rectCurrentLocal ? { x: state.rectCurrentLocal.x, y: state.rectCurrentLocal.y } : null;
      draw();
    }

    function pushHistory() {
      if (!fgImg) return;
      const snap = getStateSnapshot();
      if (!snap) return;
      const snapCopy = cloneState(snap);
      history = history.slice(0, historyIndex + 1);
      history.push(snapCopy);
      historyIndex = history.length - 1;
    }

    function undo() {
      if (historyIndex <= 0) {
        setStatus('æ²¡æœ‰æ›´å¤šå¯æ’¤å›çš„æ“ä½œ');
        return;
      }
      historyIndex--;
      restoreState(history[historyIndex]);
      setStatus('å·²æ’¤å›ä¸€æ­¥æ“ä½œ');
    }

    function redo() {
      if (historyIndex < 0 || historyIndex >= history.length - 1) {
        setStatus('æ²¡æœ‰æ›´å¤šå¯æ¢å¤çš„æ“ä½œ');
        return;
      }
      historyIndex++;
      restoreState(history[historyIndex]);
      setStatus('å·²æ¢å¤ä¸€æ­¥æ“ä½œ');
    }

    function resetOperation() {
      if (!initialFgState) {
        setStatus('å½“å‰æ²¡æœ‰å¯é‡ç½®çš„æ“ä½œ');
        return;
      }
      const base = cloneState(initialFgState);
      restoreState(base);
      history = [cloneState(base)];
      historyIndex = 0;
      setStatus('å·²é‡ç½®åˆ°åˆšåŠ è½½ç´ ææ—¶çš„çŠ¶æ€');
    }

    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);
    resetOpBtn.addEventListener('click', resetOperation);

    // ========= ç»˜åˆ¶ä¸»å¾ªç¯ =========
    function draw() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ç”»åº•å›¾
      if (bgImg) {
        ctx.save();
        ctx.setTransform(viewScale, 0, 0, viewScale, viewOffsetX, viewOffsetY);
        const bgX = -bgImg.width / 2;
        const bgY = -bgImg.height / 2;
        ctx.drawImage(bgImg, bgX, bgY);
        ctx.restore();
      }

      // ç”»å‰æ™¯ç´ æ
      if (fgImg && fgQuad) {
        if (hasPerspective) {
          const quadScreen = fgQuad.map(p => worldToScreen(p.x, p.y));
          drawWarpedImageScreen(ctx, fgImg, quadScreen, 0);
          drawQuadOverlay(ctx, quadScreen, toolMode === 'transform');
        } else {
          ctx.save();
          ctx.setTransform(viewScale, 0, 0, viewScale, viewOffsetX, viewOffsetY);

          ctx.translate(fgPosX, fgPosY);
          ctx.scale(fgScale, fgScale);
          ctx.drawImage(fgImg, 0, 0);

          // è·¯å¾„å¯è§†åŒ–ï¼ˆé’¢ç¬”/çŸ©å½¢ï¼‰
          if ((toolMode === 'pen' || toolMode === 'rect') && maskPoints.length > 0) {
            ctx.beginPath();
            ctx.moveTo(maskPoints[0].x, maskPoints[0].y);
            for (let i = 1; i < maskPoints.length; i++) ctx.lineTo(maskPoints[i].x, maskPoints[i].y);
            ctx.closePath();
            ctx.lineWidth = 1 / fgScale;
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.9)';
            ctx.setLineDash([4 / fgScale, 4 / fgScale]);
            ctx.stroke();
            ctx.setLineDash([]);

            for (let i = 0; i < maskPoints.length; i++) {
              const p = maskPoints[i];
              ctx.beginPath();
              ctx.arc(p.x, p.y, 4 / fgScale, 0, Math.PI * 2);
              ctx.fillStyle = i === draggingPointIndex ? '#ff9800' : '#00ffff';
              ctx.fill();
              ctx.strokeStyle = '#000';
              ctx.lineWidth = 1 / fgScale;
              ctx.stroke();
            }
          }

          // çŸ©å½¢å®æ—¶é¢„è§ˆ
          if (toolMode === 'rect' && isRectDrawing && rectStartLocal && rectCurrentLocal) {
            const x1 = rectStartLocal.x;
            const y1 = rectStartLocal.y;
            const x2 = rectCurrentLocal.x;
            const y2 = rectCurrentLocal.y;
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            ctx.beginPath();
            ctx.rect(minX, minY, maxX - minX, maxY - minY);
            ctx.lineWidth = 1 / fgScale;
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.9)';
            ctx.setLineDash([4 / fgScale, 4 / fgScale]);
            ctx.stroke();
            ctx.setLineDash([]);
          }

          ctx.restore();

          // å¤–æ¥çŸ©å½¢ï¼ˆç±» Ctrl+T è¾¹æ¡†ï¼‰
          ctx.save();
          ctx.setTransform(viewScale, 0, 0, viewScale, viewOffsetX, viewOffsetY);
          ctx.strokeStyle = 'rgba(255,255,255,0.7)';
          ctx.lineWidth = 1 / viewScale;
          ctx.setLineDash([6 / viewScale, 4 / viewScale]);
          ctx.strokeRect(fgPosX, fgPosY, fgImg.width * fgScale, fgImg.height * fgScale);
          ctx.restore();
        }
      }

      overlayInfo.textContent = `ç¼©æ”¾: ${(viewScale * 100).toFixed(0)}% | ç´ æç¼©æ”¾: ${(fgScale * 100).toFixed(0)}%`;
    }

    function fitViewToBg() {
      if (!bgImg) return;
      const margin = 40;
      const scaleX = (canvas.width - margin * 2) / bgImg.width;
      const scaleY = (canvas.height - margin * 2) / bgImg.height;
      viewScale = Math.min(scaleX, scaleY);
      viewOffsetX = canvas.width / 2;
      viewOffsetY = canvas.height / 2;
    }

    // ========= å›¾ç‰‡åŠ è½½ =========
    bgLoader.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        // å¦‚æœä»»æ„ä¸€æ¡è¾¹å¤§äº 3000 åƒç´ ï¼Œåˆ™ç›´æ¥æŒ‰åŸå§‹åˆ†è¾¨ç‡åŠ è½½ï¼Œé¿å…æ”¾å¤§åˆ° 300DPI å¯¼è‡´å¡é¡¿
        if (img.width > 3000 || img.height > 3000) {
          bgImg = img;
          fitViewToBg();
          setStatus('åº•å›¾å°ºå¯¸è¾ƒå¤§ï¼Œä¿æŒåŸå§‹åˆ†è¾¨ç‡åŠ è½½');
          draw();
          return;
        }

        // å¦åˆ™ï¼Œå°†åº•å›¾é»˜è®¤æå‡è‡³ 300 DPI ç­‰æ•ˆåƒç´ ï¼ˆå‡è®¾åŸå§‹ä¸º 72DPIï¼‰
        const dpiScale = 300 / 72;
        const upW = Math.round(img.width * dpiScale);
        const upH = Math.round(img.height * dpiScale);

        const upCanvas = document.createElement('canvas');
        upCanvas.width = upW;
        upCanvas.height = upH;
        const upCtx = upCanvas.getContext('2d');
        upCtx.imageSmoothingEnabled = true;
        upCtx.drawImage(img, 0, 0, upW, upH);

        bgImg = new Image();
        bgImg.onload = () => {
          fitViewToBg();
          setStatus('åº•å›¾å·²è‡ªåŠ¨æå‡è‡³ 300 DPI åˆ†è¾¨ç‡');
          draw();
        };
        bgImg.src = upCanvas.toDataURL();
      };
      img.src = URL.createObjectURL(file);
    });

    fgLoader.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        fgImg = img;
        fgScale = 1.0;
        hasPerspective = false;
        maskPoints = [];
        isRectDrawing = false;
        rectStartLocal = rectCurrentLocal = null;

        if (bgImg) {
          fgPosX = -img.width / 2 + bgImg.width / 4;
          fgPosY = -img.height / 2;
        } else {
          fgPosX = -img.width / 2;
          fgPosY = -img.height / 2;
        }
        updateFgQuadFromRect();
        setStatus('ç´ æåŠ è½½å®Œæˆ');
        draw();

        // åˆå§‹åŒ–å†å²è®°å½•å’Œåˆå§‹çŠ¶æ€
        const snap = getStateSnapshot();
        initialFgState = snap ? cloneState(snap) : null;
        history = snap ? [cloneState(snap)] : [];
        historyIndex = snap ? 0 : -1;
      };
      img.src = URL.createObjectURL(file);
    });

    // ========= å·¥å…·æŒ‰é’® =========
    function setToolMode(mode) {
      // å¦‚æœå½“å‰ç´ æå·²ç»åšè¿‡é€è§†å˜å½¢ï¼Œå¹¶ä¸”å‡†å¤‡å†æŠ å›¾ï¼Œåˆ™å…ˆæŠŠé€è§†æ•ˆæœçƒ˜ç„™æˆæ–°çš„å›¾å±‚
      if ((mode === 'pen' || mode === 'rect') && hasPerspective && fgImg && fgQuad) {
        bakePerspectiveToAxisAligned();
        pushHistory();
        setStatus('å·²å°†å½“å‰é€è§†å˜å½¢çƒ˜ç„™ä¸ºæ–°çš„å›¾å±‚ï¼ŒæŠ å›¾å°†åœ¨ç°æœ‰åŸºç¡€ä¸Šè¿›è¡Œ');
      }

      toolMode = mode;
      moveToolBtn.classList.remove('active');
      transformToolBtn.classList.remove('active');
      penToolBtn.classList.remove('active');
      rectToolBtn.classList.remove('active');

      if (mode === 'move') {
        moveToolBtn.classList.add('active');
        setStatus('ç§»åŠ¨å·¥å…· (V)ï¼šæ‹–åŠ¨ç´ æå¹³ç§»ï¼ŒCtrl+=/- æˆ–æŒ‰é’® ç­‰æ¯”ç¼©æ”¾');
      } else if (mode === 'transform') {
        transformToolBtn.classList.add('active');
        setStatus('é€è§†å˜æ¢ï¼šæ‹–åŠ¨å››ä¸ªè§’ç‚¹è¿›è¡Œé€è§†è‡ªç”±å˜å½¢');
      } else if (mode === 'pen') {
        penToolBtn.classList.add('active');
        setStatus('é’¢ç¬”æŠ å›¾ (P)ï¼šç‚¹å‡»æ·»åŠ /æ‹–åŠ¨é”šç‚¹ï¼ŒShift çº¦æŸä¸ºæ°´å¹³/å‚ç›´ï¼Œå®Œæˆåç‚¹å‡»â€œåº”ç”¨æŠ å›¾â€');
      } else if (mode === 'rect') {
        rectToolBtn.classList.add('active');
        setStatus('çŸ©å½¢æŠ å›¾ (R)ï¼šæŒ‰ä¸‹å·¦é”®æ‹–å‡ºçŸ©å½¢ï¼Œæ¾å¼€åå†ç‚¹å‡»â€œåº”ç”¨æŠ å›¾â€');
      }

      draggingPointIndex = -1;
      draggingCornerIndex = -1;
      draw();
    }

    moveToolBtn.addEventListener('click', () => setToolMode('move'));
    transformToolBtn.addEventListener('click', () => setToolMode('transform'));
    penToolBtn.addEventListener('click', () => setToolMode('pen'));
    rectToolBtn.addEventListener('click', () => setToolMode('rect'));

    clearMaskBtn.addEventListener('click', () => {
      maskPoints = [];
      isRectDrawing = false;
      rectStartLocal = rectCurrentLocal = null;
      draggingPointIndex = -1;
      setStatus('å·²æ¸…é™¤å½“å‰æŠ å›¾è·¯å¾„');
      pushHistory();
      draw();
    });

    applyMaskBtn.addEventListener('click', () => {
      if (!fgImg) {
        alert('è¯·å…ˆåŠ è½½ç´ æ');
        return;
      }
      if (maskPoints.length < 3) {
        alert('è¯·å…ˆç”¨é’¢ç¬”/çŸ©å½¢ç”»å‡ºä¸€ä¸ªå°é—­è·¯å¾„');
        return;
      }

      // è®¡ç®—è·¯å¾„å¤–æ¥çŸ©å½¢
      let minX = fgImg.width;
      let maxX = 0;
      let minY = fgImg.height;
      let maxY = 0;
      for (const p of maskPoints) {
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      }
      minX = Math.max(0, Math.floor(minX));
      minY = Math.max(0, Math.floor(minY));
      maxX = Math.min(fgImg.width, Math.ceil(maxX));
      maxY = Math.min(fgImg.height, Math.ceil(maxY));
      const cropW = maxX - minX;
      const cropH = maxY - minY;
      if (cropW <= 0 || cropH <= 0) {
        alert('æŠ å›¾èŒƒå›´æ— æ•ˆï¼Œè¯·æ£€æŸ¥è·¯å¾„');
        return;
      }

      // åœ¨æ–° canvas ä¸­æŒ‰è·¯å¾„è£åˆ‡å‡ºè¿™ä¸€å—
      const cropCanvas = document.createElement('canvas');
      cropCanvas.width = cropW;
      cropCanvas.height = cropH;
      const cropCtx = cropCanvas.getContext('2d');
      cropCtx.clearRect(0, 0, cropW, cropH);

      cropCtx.save();
      cropCtx.beginPath();
      cropCtx.moveTo(maskPoints[0].x - minX, maskPoints[0].y - minY);
      for (let i = 1; i < maskPoints.length; i++) {
        cropCtx.lineTo(maskPoints[i].x - minX, maskPoints[i].y - minY);
      }
      cropCtx.closePath();
      cropCtx.clip();
      cropCtx.drawImage(fgImg, -minX, -minY);
      cropCtx.restore();

      // ä¸–ç•Œåæ ‡ä¸­ï¼Œå¯¹åº”å·¦ä¸Šè§’çš„ä½ç½®
      const newPosX = fgPosX + minX * fgScale;
      const newPosY = fgPosY + minY * fgScale;

      fgImg = cropCanvas;
      fgPosX = newPosX;
      fgPosY = newPosY;
      hasPerspective = false;
      maskPoints = [];
      isRectDrawing = false;
      rectStartLocal = rectCurrentLocal = null;
      updateFgQuadFromRect();

      setStatus('å·²æ ¹æ®è·¯å¾„è£åˆ‡ç”Ÿæˆæ–°çš„ç´ æå›¾å±‚ï¼Œåç»­å˜æ¢éƒ½ä½œç”¨åœ¨è¿™å—å›¾å±‚ä¸Š');
      pushHistory();
      draw();
    });

    // ========= ç­‰æ¯”ç¼©æ”¾ =========
    function uniformScale(factor) {
      if (!fgImg) return;
      if (hasPerspective && fgQuad) {
        const cx = (fgQuad[0].x + fgQuad[2].x) / 2;
        const cy = (fgQuad[0].y + fgQuad[2].y) / 2;
        for (let i = 0; i < 4; i++) {
          fgQuad[i].x = cx + (fgQuad[i].x - cx) * factor;
          fgQuad[i].y = cy + (fgQuad[i].y - cy) * factor;
        }
      } else {
        fgScale *= factor;
        fgScale = Math.min(Math.max(fgScale, 0.05), 20);
        updateFgQuadFromRect();
      }
      setStatus(factor > 1 ? 'ç´ æç­‰æ¯”æ”¾å¤§' : 'ç´ æç­‰æ¯”ç¼©å°');
      pushHistory();
      draw();
    }

    scaleUpBtn.addEventListener('click', () => uniformScale(1.1));
    scaleDownBtn.addEventListener('click', () => uniformScale(0.9));

    // ========= é¼ æ ‡äº‹ä»¶ =========
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;

      if (e.button === 0) {
        isLeftDragging = true;
        dragStartX = sx;
        dragStartY = sy;

        if (!fgImg) return;
        const quadScreen = fgQuad ? fgQuad.map(p => worldToScreen(p.x, p.y)) : null;

        if (toolMode === 'move') {
          if (quadScreen && isPointInQuadScreen(sx, sy, quadScreen)) {
            if (hasPerspective) {
              dragStartQuad = fgQuad.map(p => ({ x: p.x, y: p.y }));
            } else {
              dragStartFgPosX = fgPosX;
              dragStartFgPosY = fgPosY;
            }
            setStatus('æ‹–åŠ¨ç´ æä¸­...');
          }
        } else if (toolMode === 'pen') {
          const hitIndex = hitMaskPointForPen(sx, sy);
          if (hitIndex >= 0) {
            draggingPointIndex = hitIndex;
            setStatus('æ‹–åŠ¨é”šç‚¹ä¸­...');
          } else if (isPointOnFgScreen(sx, sy)) {
            const world = screenToWorld(sx, sy);
            let local = worldToFgLocal(world.x, world.y);
            if (maskPoints.length > 0 && e.shiftKey) {
              // Shiftï¼šç›¸å¯¹ä¸Šä¸€ä¸ªç‚¹çº¦æŸä¸ºæ°´å¹³/å‚ç›´
              const base = maskPoints[maskPoints.length - 1];
              local = snapToAxis(base, local);
            }
            maskPoints.push(local);
            draggingPointIndex = maskPoints.length - 1;
            setStatus('æ·»åŠ é”šç‚¹');
            draw();
          }
        } else if (toolMode === 'rect') {
          if (isPointOnFgScreen(sx, sy)) {
            const world = screenToWorld(sx, sy);
            const local = worldToFgLocal(world.x, world.y);
            isRectDrawing = true;
            rectStartLocal = { ...local };
            rectCurrentLocal = { ...local };
            maskPoints = []; // é‡æ–°å¼€å§‹ä¸€å—çŸ©å½¢
            setStatus('æ‹–åŠ¨ä»¥ç»˜åˆ¶çŸ©å½¢è·¯å¾„');
            draw();
          }
        } else if (toolMode === 'transform') {
          if (!fgQuad || !quadScreen) return;
          const corner = hitQuadCorner(sx, sy, quadScreen, 10);
          dragStartQuad = fgQuad.map(p => ({ x: p.x, y: p.y }));
          if (corner >= 0) {
            draggingCornerIndex = corner;
            setStatus('æ‹–åŠ¨å˜æ¢è§’ç‚¹ä¸­...');
          } else if (isPointInQuadScreen(sx, sy, quadScreen)) {
            draggingCornerIndex = -1;
            setStatus('æ‹–åŠ¨ç´ æä¸­...');
          }
        }
      } else if (e.button === 2) {
        isRightDragging = true;
        dragStartX = sx;
        dragStartY = sy;
        dragStartViewOffsetX = viewOffsetX;
        dragStartViewOffsetY = viewOffsetY;
        setStatus('å¹³ç§»è§†å›¾ä¸­...');
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;

      if (isLeftDragging && fgImg) {
        const dxScreen = sx - dragStartX;
        const dyScreen = sy - dragStartY;
        const dxWorld = dxScreen / viewScale;
        const dyWorld = dyScreen / viewScale;

        if (toolMode === 'move') {
          if (hasPerspective && dragStartQuad) {
            for (let i = 0; i < 4; i++) {
              fgQuad[i].x = dragStartQuad[i].x + dxWorld;
              fgQuad[i].y = dragStartQuad[i].y + dyWorld;
            }
          } else {
            fgPosX = dragStartFgPosX + dxWorld;
            fgPosY = dragStartFgPosY + dyWorld;
            updateFgQuadFromRect();
          }
          draw();
        } else if (toolMode === 'pen' && draggingPointIndex >= 0) {
          const world = screenToWorld(sx, sy);
          let local = worldToFgLocal(world.x, world.y);
          if (e.shiftKey && maskPoints.length > 1) {
            const idx = draggingPointIndex;
            const ref = idx > 0 ? maskPoints[idx - 1] : maskPoints[1];
            if (ref) local = snapToAxis(ref, local);
          }
          maskPoints[draggingPointIndex].x = local.x;
          maskPoints[draggingPointIndex].y = local.y;
          draw();
        } else if (toolMode === 'rect' && isRectDrawing && rectStartLocal) {
          const world = screenToWorld(sx, sy);
          let local = worldToFgLocal(world.x, world.y);
          if (e.shiftKey) {
            const dx = local.x - rectStartLocal.x;
            const dy = local.y - rectStartLocal.y;
            const size = Math.max(Math.abs(dx), Math.abs(dy));
            local = {
              x: rectStartLocal.x + Math.sign(dx || 1) * size,
              y: rectStartLocal.y + Math.sign(dy || 1) * size
            };
          }
          rectCurrentLocal = local;
          draw();
        } else if (toolMode === 'transform' && dragStartQuad) {
          hasPerspective = true;
          if (draggingCornerIndex >= 0) {
            const base = dragStartQuad[draggingCornerIndex];
            fgQuad[draggingCornerIndex] = { x: base.x + dxWorld, y: base.y + dyWorld };
          } else {
            for (let i = 0; i < 4; i++) {
              fgQuad[i].x = dragStartQuad[i].x + dxWorld;
              fgQuad[i].y = dragStartQuad[i].y + dyWorld;
            }
          }
          draw();
        }
      }

      if (isRightDragging) {
        const dx = sx - dragStartX;
        const dy = sy - dragStartY;
        viewOffsetX = dragStartViewOffsetX + dx;
        viewOffsetY = dragStartViewOffsetY + dy;
        draw();
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (e.button === 0) {
        if (toolMode === 'rect' && isRectDrawing && rectStartLocal && rectCurrentLocal) {
          const x1 = rectStartLocal.x;
          const y1 = rectStartLocal.y;
          const x2 = rectCurrentLocal.x;
          const y2 = rectCurrentLocal.y;
          const minX = Math.min(x1, x2);
          const maxX = Math.max(x1, x2);
          const minY = Math.min(y1, y2);
          const maxY = Math.max(y1, y2);
          if (maxX - minX > 1 && maxY - minY > 1) {
            maskPoints = [
              { x: minX, y: minY },
              { x: maxX, y: minY },
              { x: maxX, y: maxY },
              { x: minX, y: maxY }
            ];
            setStatus('çŸ©å½¢è·¯å¾„å·²ç”Ÿæˆï¼Œè¯·ç‚¹å‡»â€œåº”ç”¨æŠ å›¾â€');
          }
          isRectDrawing = false;
          rectStartLocal = rectCurrentLocal = null;
          draw();
        }

        if (fgImg) {
          pushHistory();
        }

        isLeftDragging = false;
        draggingPointIndex = -1;
        draggingCornerIndex = -1;
        dragStartQuad = null;

        if (toolMode === 'move') setStatus('ç§»åŠ¨å·¥å…· (V)');
        if (toolMode === 'pen') setStatus('é’¢ç¬”æŠ å›¾ (P)ï¼šShift å¯çº¦æŸæ°´å¹³/å‚ç›´ï¼Œå®Œæˆåç‚¹å‡»â€œåº”ç”¨æŠ å›¾â€');
        if (toolMode === 'transform') setStatus('é€è§†å˜æ¢ï¼šæ‹–åŠ¨å››è§’è¿›è¡Œé€è§†è‡ªç”±å˜å½¢');
        if (toolMode === 'rect') setStatus('çŸ©å½¢æŠ å›¾ (R)ï¼šæ‹–å‡ºçŸ©å½¢åç‚¹å‡»â€œåº”ç”¨æŠ å›¾â€');
      } else if (e.button === 2) {
        isRightDragging = false;
        setStatus('è§†å›¾å¹³ç§»å®Œæˆ');
      }
    });

    canvas.addEventListener('mouseleave', () => {
      isLeftDragging = false;
      isRightDragging = false;
      draggingPointIndex = -1;
      draggingCornerIndex = -1;
      dragStartQuad = null;
      if (toolMode === 'rect') {
        isRectDrawing = false;
        rectStartLocal = rectCurrentLocal = null;
      }
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // ========= æ»šè½®ç¼©æ”¾è§†å›¾ =========
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;

      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      const before = screenToWorld(sx, sy);

      viewScale *= zoomFactor;
      viewScale = Math.min(Math.max(viewScale, 0.1), 10);

      const after = screenToWorld(sx, sy);
      viewOffsetX += (before.x - after.x) * viewScale;
      viewOffsetY += (before.y - after.y) * viewScale;

      draw();
    }, { passive: false });

    // ========= é”®ç›˜å¿«æ·é”® =========
    window.addEventListener('keydown', (e) => {
      if (e.key === 'v' || e.key === 'V') setToolMode('move');
      else if (e.key === 'p' || e.key === 'P') setToolMode('pen');
      else if (e.key === 't' || e.key === 'T') setToolMode('transform');
      else if (e.key === 'r' || e.key === 'R') setToolMode('rect');

      if (fgImg && e.ctrlKey && (e.key === '=' || e.key === '+')) {
        uniformScale(1.1);
        e.preventDefault();
      }
      if (fgImg && e.ctrlKey && e.key === '-') {
        uniformScale(0.9);
        e.preventDefault();
      }

      // ç®€å•å¢åŠ é”®ç›˜æ’¤å›ï¼ˆCtrl+Z / Ctrl+Shift+Zï¼‰
      if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) {
        if (e.shiftKey) {
          redo();
        } else {
          undo();
        }
        e.preventDefault();
      }
    });

    // ========= å¯¼å‡º PNGï¼ˆå°ºå¯¸ä¸åº•å›¾åƒç´ å®Œå…¨ä¸€è‡´ï¼‰ =========
    exportBtn.addEventListener('click', () => {
      if (!bgImg) {
        alert('è¯·å…ˆåŠ è½½åº•å›¾');
        return;
      }
      const exportCanvas = document.createElement('canvas');
      const exportCtx = exportCanvas.getContext('2d');
      exportCanvas.width = bgImg.width;
      exportCanvas.height = bgImg.height;

      // å¯¼å‡ºæ—¶å®Œå…¨æŒ‰ç…§åŸå§‹åƒç´ åæ ‡ç»˜åˆ¶ï¼Œä¸å— viewScale å½±å“
      exportCtx.drawImage(bgImg, 0, 0);

      if (fgImg && fgQuad) {
        const bgOriginX = bgImg.width / 2;
        const bgOriginY = bgImg.height / 2;
        const quadPixels = fgQuad.map(p => ({
          x: bgOriginX + p.x,
          y: bgOriginY + p.y
        }));
        drawWarpedImageScreen(exportCtx, fgImg, quadPixels, 0);
      }

      const url = exportCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'export.png';
      a.click();
      setStatus('å¯¼å‡ºå®Œæˆï¼ˆå°ºå¯¸ä¸åº•å›¾ä¸€è‡´ï¼‰');
    });

    // åˆå§‹ç»˜åˆ¶
    draw();
  </script>
</body>
</html>
